
#ifndef GENERATIONUTILITIES_USF
#define GENERATIONUTILITIES_USF

#include "NoiseLib.usf"

//input and output buffers
Buffer<float3> Input;
RWTexture2D<float4> BiomeMap;
Texture2D<float4> CurveAtlas;
Texture2D<float> BiomeDataTexture;
RWBuffer<float> Output;
RWBuffer<uint> OutputVC;
uint biomeCount;
int chunkQuality;
float3 chunkLocation;
int3 chunkRotation;
float3 chunkOriginLocation;
float   chunkSize;
float   planetRadius;
float   noiseHeight;


struct TerrainData
{
    float erosion;
    float finalElevation;
    uint forestNoise;
    uint3 top3BiomeIndices;
    float3 top3BiomeStrengths;
};



float3 TransformLocation(float3 transformPos, int3 transformRotDeg, float3 localLocation)
{
    int3 rotation = transformRotDeg;
    if (rotation.x == 0 && rotation.y == -1 && rotation.z == 0)
        return float3(localLocation.x, 0, localLocation.y) + transformPos;
    if (rotation.x == 0 && rotation.y == 1 && rotation.z == 0)
        return float3(localLocation.x, 0, -localLocation.y) + transformPos;
    if (rotation.x == -1 && rotation.y == 0 && rotation.z == 0)
        return float3(0, localLocation.y, localLocation.x) + transformPos;
    if (rotation.x == 0 && rotation.y == 0 && rotation.z == 1)
        return float3(localLocation.x, localLocation.y, 0) + transformPos;
    if (rotation.x == 0 && rotation.y == 0 && rotation.z == -1)
        return float3(-localLocation.x, localLocation.y, 0) + transformPos;
    if (rotation.x == 1 && rotation.y == 0 && rotation.z == 0)
        return float3(0, localLocation.y, -localLocation.x) + transformPos;
    return localLocation + transformPos;
}

float3 GetVertexPosition(uint2 DispatchThreadID)
{
    float Size = (chunkSize / chunkQuality);
    
    uint x = DispatchThreadID.x;
    uint y = DispatchThreadID.y;

    //transfer chunkLocation to -1, 1 range
    float originalchunkSize = planetRadius * 2.0 / sqrt(2.0);
    
    float localX = x * Size / (originalchunkSize / 2);
    float localY = y * Size / (originalchunkSize / 2);
    float3 localPos = float3(localX, localY, 0.0);
    
    float3 LocalchunkLocation = chunkLocation / (originalchunkSize / 2.0);
    
    float3 planetPos = TransformLocation(LocalchunkLocation, chunkRotation, localPos);

    // Apply deformation
    float Deformation = 0.75;
    planetPos.x = tan(planetPos.x * PI * Deformation / 4.0);
    planetPos.y = tan(planetPos.y * PI * Deformation / 4.0);
    planetPos.z = tan(planetPos.z * PI * Deformation / 4.0);

    return planetPos;
}


float evaluateTemperature(float3 pos, float temperatureNoiseScale)
{
    float3 normalizedPos = normalize(pos);
    float latTemp = 1.0f - abs(normalizedPos.z);
    // Assume higher baseElevation (land) is colder; underwater remains moderate.
    //float elevEffect = 0.0;//(baseElevation > 0.0) ? (saturate(baseElevation * 2 - 0.5)) : 1.0;
    return saturate(latTemp + ((fbmE(pos * temperatureNoiseScale, 2, 1) - 0.5) * 2) * 0.05);
}

float readCurveR(int row, float x)
{
    float texWidth = 256.0;

    // Clamp x inside [0, 1]
    x = saturate(x / 2.0 + 0.5);

    // Scale to texel space
    float texCoordX = x * (texWidth - 1.0);

    float baseX = floor(texCoordX);
    float nextX = baseX + 1.0;

    float fracX = texCoordX - baseX;

    // Correct last pixel handling
    bool isLastPixel = baseX >= (texWidth - 1.0);
    if (isLastPixel)
    {
        nextX = baseX;
        fracX = 0.0;
    }

    int2 baseCoord = int2(int(baseX), row);
    int2 nextCoord = int2(int(min(nextX, texWidth - 1.0)), row);

    // Read raw values
    float valueA = CurveAtlas[baseCoord].x;
    float valueB = CurveAtlas[nextCoord].x;

    // Interpolate
    float value = lerp(valueA, valueB, fracX);

    // Decode to [-1, 1] range
    value = (value - 0.5) * 2.0;

    return value;
}




float readCurveG(int row, float x)
{
    float texWidth = 256.0;

    // Clamp x inside [0, 1]
    x = saturate(x / 2.0 + 0.5);

    // Scale to texel space
    float texCoordX = x * (texWidth - 1.0);

    float baseX = floor(texCoordX);
    float nextX = baseX + 1.0;

    float fracX = texCoordX - baseX;

    // Correct last pixel handling
    bool isLastPixel = baseX >= (texWidth - 1.0);
    if (isLastPixel)
    {
        nextX = baseX;
        fracX = 0.0;
    }

    int2 baseCoord = int2(int(baseX), row);
    int2 nextCoord = int2(int(min(nextX, texWidth - 1.0)), row);

    // Read raw values
    float valueA = CurveAtlas[baseCoord].y;
    float valueB = CurveAtlas[nextCoord].y;

    // Interpolate
    float value = lerp(valueA, valueB, fracX);

    // Decode to [-1, 1] range
    value = (value - 0.5) * 2.0;

    return value;
}

float readCurveB(int row, float x)
{
    float texWidth = 256.0;

    // Clamp x inside [0, 1]
    x = saturate(x / 2.0 + 0.5);

    // Scale to texel space
    float texCoordX = x * (texWidth - 1.0);

    float baseX = floor(texCoordX);
    float nextX = baseX + 1.0;

    float fracX = texCoordX - baseX;

    // Correct last pixel handling
    bool isLastPixel = baseX >= (texWidth - 1.0);
    if (isLastPixel)
    {
        nextX = baseX;
        fracX = 0.0;
    }

    int2 baseCoord = int2(int(baseX), row);
    int2 nextCoord = int2(int(min(nextX, texWidth - 1.0)), row);

    // Read raw values
    float valueA = CurveAtlas[baseCoord].z;
    float valueB = CurveAtlas[nextCoord].z;

    // Interpolate
    float value = lerp(valueA, valueB, fracX);

    // Decode to [-1, 1] range
    value = (value - 0.5) * 2.0;

    return value;
}

#include "BiomeMasks.usf"

//parameter 0 = Curve, 1 = Forest, 2 = Material, 3 = MaskCount, 4..N = MaskIndices
float ReadBiomeDataTexture(uint biomeindex, uint parameter)
{
    return BiomeDataTexture[uint2(parameter, biomeindex)];
}

float3 sampleBiomes(
    float3 pos, // Planet position
    float height, // Specialized for mask inputs
    float arg1,
    float arg2,
    float arg3,
    out uint3 top3BiomeIndices,
    out float3 top3BiomeStrengths
)
{
    static const uint MAX_BIOMES_STATIC = 16; 
    uint actualLoopCount = min(biomeCount, MAX_BIOMES_STATIC);
    
    // Max masks we can cache (e.g. indices 0 to 15)
    static const int MAX_MASK_CACHE = 16;

    // CACHE: Store results of GetBiomeMask to avoid re-calculation
    // Initialize to -1.0 to indicate "not calculated yet"
    float maskCache[MAX_MASK_CACHE];
    for(int m = 0; m < MAX_MASK_CACHE; m++) maskCache[m] = -1.0;

    // Pass 1: Coverage Calculation (Top-Down Layering)
    // Iterate from highest priority (last biome) to lowest (base)
    float weights[MAX_BIOMES_STATIC];
    for (int k = 0; k < MAX_BIOMES_STATIC; k++) weights[k] = 0.0; // Init to 0

    float coverage = 0.0;

    // Iterate from top layer down to layer 1
    for (int i = actualLoopCount - 1; i >= 1; --i) 
    {
        if (coverage >= 0.999) break;

        int count = int(ReadBiomeDataTexture(i, 3)); // Index 3 is MaskCount
        float combinedMask = 1.0;

        for (int m = 0; m < count; m++)
        {
            int maskIdx = int(ReadBiomeDataTexture(i, 4 + m)); // Masks start at 4
            float maskVal = 0.0;

            // Check Cache
            if (maskIdx < MAX_MASK_CACHE)
            {
                if (maskCache[maskIdx] < -0.5) // if -1
                {
                    maskCache[maskIdx] = GetBiomeMask(maskIdx, pos, height);
                }
                maskVal = maskCache[maskIdx];
            }
            else
            {
                // Fallback for high indices (uncached)
                maskVal = GetBiomeMask(maskIdx, pos, height);
            }

            combinedMask *= maskVal;
        }
        
        float contribution = min(combinedMask, 1.0 - coverage);
        weights[i] = contribution;
        coverage += contribution;
    }
    // Base biome (0) fills the gaps
    weights[0] = 1.0 - coverage;

    // Pass 2: Select Top 3 for Materials (Sorting)
    uint topIdx[3] = {0, 0, 0};
    float topW[3] = {0.0, 0.0, 0.0};

    // Find top 3 by weight
    for (int i = 0; i < actualLoopCount; ++i)
    {
        float w = weights[i];
        if (w > topW[0]) {
            topW[2] = topW[1]; topIdx[2] = topIdx[1];
            topW[1] = topW[0]; topIdx[1] = topIdx[0];
            topW[0] = w;       topIdx[0] = i;
        } else if (w > topW[1]) {
            topW[2] = topW[1]; topIdx[2] = topIdx[1];
            topW[1] = w;       topIdx[1] = i;
        } else if (w > topW[2]) {
            topW[2] = w;       topIdx[2] = i;
        }
    }
    
    top3BiomeIndices = uint3(topIdx[0], topIdx[1], topIdx[2]);

    // Normalize top 3 for material blending
    float sum = topW[0] + topW[1] + topW[2];
    if (sum > 0.001) {
        top3BiomeStrengths = float3(topW[0] / sum, topW[1] / sum, topW[2] / sum);
    } else {
         // Fallback shouldn't happen usually due to base layer, but good for safety
        top3BiomeStrengths = float3(1.0, 0.0, 0.0);
    }

    // Terrain Blending: Uses all biomes
    float3 result = float3(0, 0, 0);

    for (int i = 0; i < actualLoopCount; ++i)
    {
        float curveValue = readCurveR(int(ReadBiomeDataTexture(i, 0)), arg1); // Index 0 is Curve
        float forestValue = readCurveG(int(ReadBiomeDataTexture(i, 0)), arg2); // Index 0 is Curve
        float materialValue = readCurveB(int(ReadBiomeDataTexture(i, 0)), arg3); // Index 0 is Curve

        result.x += curveValue * weights[i];
        result.y += forestValue * weights[i];
        result.z += materialValue * weights[i];
    }

    return result;
}


void WritePlanetData(
    uint2 DispatchThreadID,
    float3 normalizedPlanetPos,
    TerrainData terrainData
)
{
    int verticesAmount = chunkQuality + 1;
    
    // Index 2 is MaterialLayerIndex
    uint3 top3MaterialLayerIndices = uint3(
        ReadBiomeDataTexture(terrainData.top3BiomeIndices.x, 2), 
        ReadBiomeDataTexture(terrainData.top3BiomeIndices.y, 2), 
        ReadBiomeDataTexture(terrainData.top3BiomeIndices.z, 2)
    );
    
    BiomeMap[DispatchThreadID.xy] = float4(float3(float(top3MaterialLayerIndices.x) / 255.0, float(top3MaterialLayerIndices.y) / 255.0, float(top3MaterialLayerIndices.z) / 255.0), (clamp(terrainData.finalElevation, -1.0, 0.0) + 1.0));
    BiomeMap[DispatchThreadID.xy + int2(0, verticesAmount)] = float4(terrainData.top3BiomeStrengths, 1.0);

    uint index = (DispatchThreadID.y * verticesAmount + DispatchThreadID.x) * 3;
    float3 planetPos = normalizedPlanetPos * (planetRadius + clamp(terrainData.finalElevation, -1.0, 1.0) * noiseHeight);
    planetPos = planetPos - (chunkOriginLocation - chunkLocation);
    float3 chunkLocalPos = planetPos - chunkLocation;
    Output[index]     = chunkLocalPos.x;
    Output[index + 1] = chunkLocalPos.y;
    Output[index + 2] = chunkLocalPos.z;
    OutputVC[index] = uint(terrainData.erosion * 255);
    OutputVC[index + 1] = terrainData.forestNoise;
    OutputVC[index + 2] = uint(terrainData.top3BiomeIndices.x);
}



#endif