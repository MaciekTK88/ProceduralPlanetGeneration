
#ifndef NOISELIB_USF
#define NOISELIB_USF

#define PI 3.14159265359

//------------------------------------------------------------------------------
// 32‑bit finalizer from MurmurHash3 (strong bit‑avalanche)
uint fmix32(uint h) {
    h ^= h >> 16;
    h *= 0x85ebca6bu;
    h ^= h >> 13;
    h *= 0xc2b2ae35u;
    h ^= h >> 16;
    return h;
}

// 3D hash
float Hash3D(float3 p)
{
    // reinterpret each float component as a 32‑bit uint
    uint ux = asuint(p.x);
    uint uy = asuint(p.y);
    uint uz = asuint(p.z);

    // mix the three axes with three distinct large primes
    uint h = ux * 0x9e3779b1u
           ^ uy * 0x85ebca6bu
           ^ uz * 0xc2b2ae35u;

    // apply a strong 32‑bit mixer
    h = fmix32(h);

    // normalize to [0,1], mapping 0…0xFFFFFFFF → 0.0…1.0
    return float(h) / 4294967295.0;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// 3D Gradient Noise with Analytic Derivatives
float3 grad(float3 p) {
    // 3D hash to get a random gradient vector
    uint ux = asuint(p.x);
    uint uy = asuint(p.y);
    uint uz = asuint(p.z);
    uint h = ux * 0x9e3779b1u ^ uy * 0x85ebca6bu ^ uz * 0xc2b2ae35u;
    h = fmix32(h);
    
    // Convert to float in [-1, 1]
    float x_hash = float(h & 0x000F) / 7.5 - 1.0; 
    float y_hash = float((h >> 4) & 0x000F) / 7.5 - 1.0;
    float z_hash = float((h >> 8) & 0x000F) / 7.5 - 1.0;
    
    // Normalize to get a point on sphere (or close enough for noise)
    // Or simpler: map to edges of cube / 12 edges for standard Perlin
    // Let's use a simpler hash for gradients typically used in prod code (IQ style)
    
    // Using the existing Hash3D to get 3 floats might be slow. 
    // Let's us a quick pseudo-random direction.
    
    float3 r = float3(
        Hash3D(p),
        Hash3D(p + float3(12.34, 45.67, 78.90)),
        Hash3D(p + float3(55.11, 11.22, 99.88))
    );
    return normalize(r * 2.0 - 1.0);
}

// Hash for gradients
float3 hash_grad(float3 p) {
	p = float3( dot(p,float3(127.1,311.7, 74.7)),
			    dot(p,float3(269.5,183.3,246.1)),
			    dot(p,float3(113.5,271.9,124.6)));

	return -1.0 + 2.0 * frac(sin(p) * 43758.5453123);
}

// Gradient Noise 3D with derivatives
// Returns float4( value, dd.x, dd.y, dd.z )
float4 noised(float3 x)
{
    float3 p = floor(x);
    float3 w = frac(x);
    
    // Quintic interpolation
    float3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);
    float3 du = 30.0 * w * w * (w - 1.0) * (w - 1.0);
    
    // Gradients at corners
    float3 ga = hash_grad( p + float3(0,0,0) );
    float3 gb = hash_grad( p + float3(1,0,0) );
    float3 gc = hash_grad( p + float3(0,1,0) );
    float3 gd = hash_grad( p + float3(1,1,0) );
    float3 ge = hash_grad( p + float3(0,0,1) );
    float3 gf = hash_grad( p + float3(1,0,1) );
    float3 gg = hash_grad( p + float3(0,1,1) );
    float3 gh = hash_grad( p + float3(1,1,1) );
    
    // Projections
    float va = dot( ga, w - float3(0,0,0) );
    float vb = dot( gb, w - float3(1,0,0) );
    float vc = dot( gc, w - float3(0,1,0) );
    float vd = dot( gd, w - float3(1,1,0) );
    float ve = dot( ge, w - float3(0,0,1) );
    float vf = dot( gf, w - float3(1,0,1) );
    float vg = dot( gg, w - float3(0,1,1) );
    float vh = dot( gh, w - float3(1,1,1) );
	
    // Interpolation
    float k0 = va;
    float k1 = vb - va;
    float k2 = vc - va;
    float k3 = ve - va;
    float k4 = va - vb - vc + vd;
    float k5 = va - vc - ve + vg;
    float k6 = va - vb - ve + vf;
    float k7 = -va + vb + vc - vd + ve - vf - vg + vh;

    float value = k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z;

    // Derivatives
    float3 d = du * (float3(k1,k2,k3) + u.yzx*float3(k4,k5,k6) + u.zxy*float3(k6,k4,k5) + u.yzx*u.zxy*k7 ) +
               ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + 
               u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + 
               u.x*u.y*u.z*(-ga+gb+gc-gd+ge-gf-gg+gh);
               
    return float4(value, d);
}

//------------------------------------------------------------------------------
// fbmE: Fractal Brownian Motion with derivatives.
float fbmE(float3 x, int octaves, float ridgePower)
{
    float initAmplitude = 0.7;
    float amplitudeDecay = 0.55;
    float frequencyMultiplier = 2.0;
    float derivativeWeight = 1.0; 
    float ridgeOffset = 1.0;
    
    float total = 0.0;
    float3 dSum = float3(0.0, 0.0, 0.0);
    float3 pos = x;
    
    // Domain Rotation Matrix (non-aligned)
    const float3x3 rot = float3x3( 
        -0.37, -0.39,  0.84,
         0.20,  0.81,  0.54,
        -0.90,  0.36, -0.22 
    );
    
    float3x3 accumRot = float3x3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);

    for (int i = 0; i < octaves; ++i)
    {
        float4 n = noised(pos);
        float noiseVal = n.x;
        float3 noiseDeriv = n.yzw;
        
        // Accumulate derivatives for ridge/erosion effect
        // Rotate derivative back to world alignment
        dSum += mul(noiseDeriv, accumRot);

        // Ridge noise calculation
        float ridge = ridgeOffset - abs(noiseVal);
        ridge = pow(max(ridge, 0.0), ridgePower - 1.0);
        ridge *= ridge; 
        
        float dot_d = dot(dSum, dSum);
        
        total += initAmplitude * ridge / (1.0 + derivativeWeight * dot_d);
        
        initAmplitude *= amplitudeDecay;
        pos = mul(rot, pos) * frequencyMultiplier; // Rotate and Scale
        accumRot = mul(rot, accumRot);
    }

    return total * 0.85;
}



//------------------------------------------------------------------------------
float3 noised2D(float2 p)
{
    // Integer and fractional parts of the coordinate
    float2 i = floor(p);
    float2 w = frac(p);

    // Quintic interpolation curve: 6w^5 - 15w^4 + 10w^3
    float2 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);
    // Analytic derivative of the quintic curve: 30w^2(w-1)^2
    float2 du = 30.0 * w * w * (w - 1.0) * (w - 1.0);

    // Sample random values at the four corners of the grid cell
    float a = Hash3D(float3(i + float2(0.0, 0.0), 0.0));
    float b = Hash3D(float3(i + float2(1.0, 0.0), 0.0));
    float c = Hash3D(float3(i + float2(0.0, 1.0), 0.0));
    float d = Hash3D(float3(i + float2(1.0, 1.0), 0.0));

    // Bilinear interpolation of the random values using the quintic curve
    float value = lerp(lerp(a, b, u.x),
                       lerp(c, d, u.x),
                       u.y);

    // Calculate derivatives using the chain rule
    float2 derivatives;
    derivatives.x = du.x * ( (b-a)*(1.0-u.y) + (d-c)*u.y );
    derivatives.y = du.y * ( lerp(c,d,u.x) - lerp(a,b,u.x) );

    // Return value mapped to [-1, 1] and the scaled derivative
    return float3(-1.0 + 2.0 * value, 2.0 * derivatives);
}

//------------------------------------------------------------------------------
// Based on https://www.shadertoy.com/view/MtGcWh
float3 erosion2d(float2 p, float2 dir)
{
    float3 sum = float3(0.0, 0.0, 0.0);
    float wtot = 0.0;
    const float F = 2.0 * 3.14159265;
    
    float2 ip = floor(p);
    float2 fp = frac(p);
    
    for (int i = -2; i <= 1; i++)
        for (int j = -2; j <= 1; j++)
        {
            float2 o = float2(i, j);

            float2 h = float2(
                Hash3D(float3(ip - o, 0.0)),
                Hash3D(float3(ip - o + float2(1.0, 10.0), 0.0))
            ) * 0.5;

            float2 pp = fp + o - h;
            float  d  = dot(pp, pp);
            float  w  = exp(-d * 2.0);

            wtot += w;

            float m = dot(pp, dir);

            sum += float3(
                cos(m * F),
                -sin(m * F) * (pp + dir)
            ) * w;
        }

    return sum / max(wtot, 1e-5);
}


float mountain2d(float2 p, float scale, out float erosion)
{
    // --------------------------------------------------
    // Base FBM
    // --------------------------------------------------
    float3 n = float3(0.0, 0.0, 0.0);
    float freq = 1.0;
    float amp  = 0.8;
    
    for (int i = 0; i < 2; i++)
    {
        float3 d = noised2D(p * scale * freq);
        n += d * (amp * float3(1.0, freq, freq));

        amp  *= 0.5;
        freq *= 2.0;
    }

    // Base height in [0,1]
    float baseHeight = smoothstep(-1.0, 1.0, n.x);

    // --------------------------------------------------
    // Slope direction
    // --------------------------------------------------
    float2 dir = n.zy * float2(1.0, -1.0);
    float slope = saturate(length(dir));

    // --------------------------------------------------
    // Erosion masks
    // --------------------------------------------------

    // Protect peaks
    float peakMask = 1.0 - smoothstep(0.85, 1, baseHeight);

    float erosionMask = peakMask;

    // --------------------------------------------------
    // Erosion layers
    // --------------------------------------------------
    float3 hsum = float3(0.0, 0.0, 0.0);
    float  a    = 1.0;
    float  f    = 1.0;

    for (int i = 0; i < 8; i++)
    {
        float3 e = erosion2d(
            p * f * scale * 3.0,
            dir + hsum.zy * float2(1.0, -1.0)
        );

        hsum += e * (a * erosionMask * float3(1.0, f, f));

        a *= 0.4;
        f *= 2.0;
    }

    // --------------------------------------------------
    // Final erosion & height
    // --------------------------------------------------
    hsum.x = smoothstep(-1.0, 1.0, hsum.x);
    erosion = hsum.x;

    float height = baseHeight + hsum.x * 0.1;

    return height;
}


float ErosionHeightTriplanar(float3 N, float scale, out float erosion)
{
    float3 w = abs(N);
    w /= (w.x + w.y + w.z + 1e-5);

    float erosionx = 0.0;
    float erosiony = 0.0;
    float erosionz = 0.0;
    
    float hx = mountain2d(N.yz, scale, erosionx);
    float hy = mountain2d(N.zx, scale, erosiony);
    float hz = mountain2d(N.xy, scale, erosionz);

    erosion =
        erosionx * w.x +
        erosiony * w.y +
        erosionz * w.z;

    return (hx * w.x + hy * w.y + hz * w.z) * 0.92;
}


//------------------------------------------------------------------------------
//Converts a normalized sphere position to UV coordinates.
float2 sphereToUV(float3 pos)
{
    // Ensure pos is normalized
    pos = normalize(pos);

    // Latitude (V) is based on the vertical (Z) axis.
    float v = asin(pos.z) / 3.14159265 + 0.5;

    // Longitude (U) is based on the horizontal X and Y axes.
    float u = atan2(pos.y, pos.x) / (2.0 * 3.14159265);
    u = frac(u + 1.0); // Ensure U is in range [0,1]

    return float2(u, v);
}


//------------------------------------------------------------------------------
//Applies an additional warp to the sphere coordinate for variation.
float3 warpPosition(float3 sphereDir, float warpStrength)
{
    float3 warp = float3(
        fbmE(sphereDir * 10.0 + float3(37.1,61.7,12.3), 3, 2),
        fbmE(sphereDir * 10.0 + float3(12.9,53.3,78.1), 3, 2),
        fbmE(sphereDir * 10.0 + float3(21.4,88.9,45.6), 3, 2)
    );
    sphereDir += normalize(warp) * warpStrength;
    return normalize(sphereDir);
}


float computeInstantPlateEffect(float3 pos, float plateSizeFactor)
{
    float plateFrequency = 8.0 * plateSizeFactor;
    float3 p = pos * plateFrequency;
    int3 ip = (int3)floor(p);
    float radius = length(pos);

    //Drift calculation
    float totalW = 0.0;
    float3 driftSum = float3(0,0,0);
    float3 drifts[27];
    float ws[27];
    int idx = 0;

    for (int i = -1; i <= 1; ++i)
        for (int j = -1; j <= 1; ++j)
            for (int k = -1; k <= 1; ++k)
            {
                int3 cell = ip + int3(i,j,k);
                float3 randOff = float3(
                    Hash3D(cell + float3(1,0,0)),
                    Hash3D(cell + float3(0,1,0)),
                    Hash3D(cell + float3(0,0,1))
                );
                float3 seedP = (float3)cell + randOff;
                float3 cellOS = pos + (seedP - p + 0.5) / plateFrequency;
                float3 cellNorm = normalize(cellOS);
                float3 dvec = p - seedP;
                float d = length(dvec);

                float latCos = sqrt(saturate(1 - pow(cellNorm.z, 2)));
                float w = exp(-d*d * 5.0) * latCos;

                float3 nrmCan = normalize((float3)cell + randOff) * plateFrequency;
                float3 dr = normalize(float3(
                    Hash3D(nrmCan + float3(10,0,0)),
                    Hash3D(nrmCan + float3(20,0,0)),
                    Hash3D(nrmCan + float3(30,0,0))
                ) - 0.5);

                driftSum += dr * w;
                totalW += w;

                drifts[idx] = dr;
                ws[idx++] = w;
            }

    if (totalW < 1e-5)
        return 0.0;

    float3 avgDr = driftSum / totalW;
    float dev = 0.0;
    for (int i = 0; i < idx; ++i)
        dev += ws[i] * length(drifts[i] - avgDr);

    float dispersion = dev / totalW;
    float effect = (dispersion - 0.5) * 3.0 * 0.04;

    return effect * 10.0;
}


// Voronoi function
float voronoi(float3 p, out float3 cellOrigin)
{
    float3 ip = floor(p);
    float3 fp = frac(p);
    float2 r = float2(2.0, 2.0);

    float3 bestCell = 0.0;

    for (int i = -1; i <= 1; ++i)
    {
        for (int j = -1; j <= 1; ++j)
        {
            for (int k = -1; k <= 1; ++k)
            {
                float3 g = float3(i, j, k);
                float3 offset = Hash3D(ip + g) * 0.3;
                float3 candidatePos = g + offset;
                float3 diff = fp - candidatePos;
                float d = dot(diff, diff);

                if (d < r.x)
                {
                    r.y = r.x;
                    r.x = d;
                    bestCell = ip + g + offset;
                }
                else if (d < r.y)
                {
                    r.y = d;
                }
            }
        }
    }

    cellOrigin = bestCell;
    return r.x;
}

// Craters function
float CratersScaled(float3 p, float scale)
{
    float3 cellOrigin;
    
    float v = voronoi(p, cellOrigin);
    
    // Base crater depression
    float base = -sin(sqrt(v) * PI * 2.0) * exp(-4.0 * v);

    // Rim parameters scale with crater size
    float rimPos    = 0.25;               // Position of rim
    float rimWidth  = 0.1 / scale;       // Thicker for large craters
    float rimHeight = 0.25 * (1.0 / scale); // Taller for large craters

    // Rim bump
    float rim = rimHeight * exp(-pow((v - rimPos) / rimWidth, 2.0));

    return base + rim;
}

float fbmCraters(float3 p)
{
    float f = 3.2;  // frequency
    float r = 0.0;

    for (int i = 0; i < 3; ++i)
    {
        r += CratersScaled(p * f, f) / (f * 0.5);
        f *= 2.7;
    }

    return r / 2.0;
}

float2 Voronoi3D(float3 x, float time)
{
    float3 n = floor(x);
    float3 f = frac(x);

    float4 m = float4(8.0, 0.0, 0.0, 0.0);

    [unroll]
    for (int k = -1; k <= 1; ++k)
    {
        [unroll]
        for (int j = -1; j <= 1; ++j)
        {
            [unroll]
            for (int i = -1; i <= 1; ++i)
            {
                float3 g = float3(i, j, k);
                float3 o = Hash3D(n + g);
                float3 r = g + (0.5 + 0.5 * sin(float3(time, time, time) + 6.2831 * o)) - f;
                float d = dot(r, r);

                if (d < m.x)
                {
                    m = float4(d, o);
                }
            }
        }
    }

    return float2(m.x, m.y + m.z + m.w);
}

//------------------------------------------------------------------------------
// Smooths elevation near water level.
float flattenElevation(float elevation, float waterLevel, float threshold)
{
    float diff = abs(elevation - waterLevel);
    float mask = smoothstep(0.0, threshold, diff);
    return lerp(waterLevel, elevation, mask);
}

#endif