#include "/Engine/Public/Platform.ush"
#include "NoiseLib.usf"

Buffer<float3> Input;
RWTexture2D<float4> InputRenderTarget;
Texture2D<float3> CurveAtlas;
Texture2D<float> BiomeDataTexture;
RWBuffer<float> Output;
RWBuffer<uint> OutputVC;
uint BiomeCountInfo;
int ChunkQualityInfo;


float3 TransformLocation(float3 transformPos, float3 transformRotDeg, float3 localLocation)
{
    int3 rotation = int3(round(transformRotDeg));
    if (rotation.x == 0 && rotation.y == -1 && rotation.z == 0)
        return float3(localLocation.x, 0, localLocation.y) + transformPos;
    if (rotation.x == 0 && rotation.y == 1 && rotation.z == 0)
        return float3(localLocation.x, 0, -localLocation.y) + transformPos;
    if (rotation.x == -1 && rotation.y == 0 && rotation.z == 0)
        return float3(0, localLocation.y, localLocation.x) + transformPos;
    if (rotation.x == 0 && rotation.y == 0 && rotation.z == 1)
        return float3(localLocation.x, localLocation.y, 0) + transformPos;
    if (rotation.x == 0 && rotation.y == 0 && rotation.z == -1)
        return float3(-localLocation.x, localLocation.y, 0) + transformPos;
    if (rotation.x == 1 && rotation.y == 0 && rotation.z == 0)
        return float3(0, localLocation.y, -localLocation.x) + transformPos;
    return localLocation + transformPos;
}

float evaluateTemperature(float3 pos, float baseElevation)
{
    float3 normalizedPos = normalize(pos);
    float latTemp = 1.0f - abs(normalizedPos.z);
    // Assume higher baseElevation (land) is colder; underwater remains moderate.
    //float elevEffect = 0.0;//(baseElevation > 0.0) ? (saturate(baseElevation * 2 - 0.5)) : 1.0;
    return saturate(latTemp + ((fbmE(pos * 3, 3, 1) - 0.5) * 2) * 0.05);
}

float readCurveR(int row, float x)
{
    float texWidth = 512.0;

    // Clamp x inside [0, 1]
    x = saturate(x / 2.0 + 0.5);

    // Scale to texel space
    float texCoordX = x * (texWidth - 1.0);

    float baseX = floor(texCoordX);
    float nextX = baseX + 1.0;

    float fracX = texCoordX - baseX;

    // Correct last pixel handling
    bool isLastPixel = baseX >= (texWidth - 1.0);
    if (isLastPixel)
    {
        nextX = baseX;
        fracX = 0.0;
    }

    int2 baseCoord = int2(int(baseX), row);
    int2 nextCoord = int2(int(min(nextX, texWidth - 1.0)), row);

    // Read raw values
    float valueA = CurveAtlas[baseCoord].x;
    float valueB = CurveAtlas[nextCoord].x;

    // Interpolate
    float value = lerp(valueA, valueB, fracX);

    // Decode to [-1, 1] range
    value = (value - 0.5) * 2.0;

    return value;
}




float readCurveG(int row, float x)
{
    float texWidth = 512.0;

    // Clamp x inside [0, 1]
    x = saturate(x / 2.0 + 0.5);

    // Scale to texel space
    float texCoordX = x * (texWidth - 1.0);

    float baseX = floor(texCoordX);
    float nextX = baseX + 1.0;

    float fracX = texCoordX - baseX;

    // Correct last pixel handling
    bool isLastPixel = baseX >= (texWidth - 1.0);
    if (isLastPixel)
    {
        nextX = baseX;
        fracX = 0.0;
    }

    int2 baseCoord = int2(int(baseX), row);
    int2 nextCoord = int2(int(min(nextX, texWidth - 1.0)), row);

    // Read raw values
    float valueA = CurveAtlas[baseCoord].y;
    float valueB = CurveAtlas[nextCoord].y;

    // Interpolate
    float value = lerp(valueA, valueB, fracX);

    // Decode to [-1, 1] range
    value = (value - 0.5) * 2.0;

    return value;
}

float readCurveB(int row, float x)
{
    float texWidth = 512.0;

    // Clamp x inside [0, 1]
    x = saturate(x / 2.0 + 0.5);

    // Scale to texel space
    float texCoordX = x * (texWidth - 1.0);

    float baseX = floor(texCoordX);
    float nextX = baseX + 1.0;

    float fracX = texCoordX - baseX;

    // Correct last pixel handling
    bool isLastPixel = baseX >= (texWidth - 1.0);
    if (isLastPixel)
    {
        nextX = baseX;
        fracX = 0.0;
    }

    int2 baseCoord = int2(int(baseX), row);
    int2 nextCoord = int2(int(min(nextX, texWidth - 1.0)), row);

    // Read raw values from blue channel
    float valueA = CurveAtlas[baseCoord].z;
    float valueB = CurveAtlas[nextCoord].z;

    // Interpolate
    float value = lerp(valueA, valueB, fracX);

    // Decode to [-1, 1] range
    value = (value - 0.5) * 2.0;

    return value;
}

//parameter 0 = minTemp parameter 1 = maxTemp parameter 2 = curveIndex parameter 3 = isforestbiome
float ReadBiomeDataTexture(uint biomeindex, uint parameter)
{
    return BiomeDataTexture[uint2(parameter, biomeindex)];
}


// Helper function to handle inclusive/exclusive range logic
bool InTempRange(float t, float mn, float mx)
{
    if (mx >= 1.0f - 1e-6)    // if this biome truly goes to the top
        return t >= mn && t <= mx;
    else
        return t >= mn && t <  mx;
}

float3 sampleBlendedCurve(
    float3 pos,
    float x,
    float y,
    float z,
    uint BiomeCount,                        // passed from CPU
    out uint dominantBiomeIndex,
    out uint3 top3BiomeIndices,
    out float3 top3BiomeStrengths
)
{
    static const uint MAX_BIOMES_STATIC = 16; 

    float temperature = evaluateTemperature(pos, 0.1);

    float weights[MAX_BIOMES_STATIC]; 
    float totalWeight = 0.0;

    // Find top 3 biome indices
    uint topIdx[3] = {0, 0, 0};
    float topW[3]  = {-1.0, -1.0, -1.0};

    float3 result = float3(0, 0, 0);
    dominantBiomeIndex = 0;

    float maxWeight = -1.0;
    
    //float noiseBias = 

    uint actualLoopCount = min(BiomeCount, MAX_BIOMES_STATIC);

    for (uint i = 0; i < actualLoopCount; ++i)
    {
        float minT = (ReadBiomeDataTexture(i, 0));
        float maxT = (ReadBiomeDataTexture(i, 1));

        float halfRange = (maxT - minT) * 0.5;
        float center = minT + halfRange;

        float tempWeight = pow(saturate(1.0 - abs(temperature - center) / halfRange), 1.5);
        
        float bias = pow(fbmE(pos * 4 + float3(i, i + 1, i + 2), 3, 1.0),2.0);
        float w = tempWeight * bias;
        totalWeight += w;
        weights[i] = w;
        
    }
    

    for (uint i = 0; i < actualLoopCount; ++i)
    {
        float w = weights[i];
        if (w > topW[0])
        {
            topW[2] = topW[1]; topIdx[2] = topIdx[1];
            topW[1] = topW[0]; topIdx[1] = topIdx[0];
            topW[0] = w;       topIdx[0] = i;
        }
        else if (w > topW[1])
        {
            topW[2] = topW[1]; topIdx[2] = topIdx[1];
            topW[1] = w;       topIdx[1] = i;
        }
        else if (w > topW[2])
        {
            topW[2] = w;       topIdx[2] = i;
        }
    }

    uint finalIdx1 = topIdx[0];
    uint finalIdx2 = (topW[1] >= 0.0) ? topIdx[1] : finalIdx1;
    uint finalIdx3 = (topW[2] >= 0.0) ? topIdx[2] : finalIdx2;

    top3BiomeIndices = uint3(finalIdx1, finalIdx2, finalIdx3);
    dominantBiomeIndex = finalIdx1;

    // Normalize top3 weights to [0,1]
    float normSum = 1;//max(topW[0],0) + max(topW[1],0) + max(topW[2],0);
    top3BiomeStrengths = float3(
        max(topW[0],0) / normSum,
        max(topW[1],0) / normSum,
        max(topW[2],0) / normSum
    );

    // Blend result using all normalized weights
    for (uint i = 0; i < actualLoopCount; ++i)
    {
        if (weights[i] > 0.0)
        {
            float normW = weights[i] / totalWeight;
            
            float rawCurveIndex = ReadBiomeDataTexture(i, 2) + 0.1;
            uint curveIndex = uint(clamp(rawCurveIndex, 0.0, 255.0));

            result += normW * float3(
                readCurveR(curveIndex, x),
                readCurveG(curveIndex, y),
                readCurveB(curveIndex, z)
            );
        }
    }

    return result;
}






//------------------------------------------------------------------------------
// ExampleComputeShader: Main compute shader entry point.
[numthreads(16, 16, 1)]
void PlanetComputeShader(
    uint3 DispatchThreadID : SV_DispatchThreadID,
    uint GroupIndex : SV_GroupIndex)
{
    // Retrieve parameters from the input buffer.
    float3 ChunkLocation      = Input[0];
    float3 ChunkRotation      = Input[1];
    float3 ChunkOriginLocation= Input[2];
    float   ChunkSize         = Input[3].x;
    float   PlanetRadius      = Input[3].y;
    float   noiseHeight       = Input[3].z;
    int ChunkQuality          = ChunkQualityInfo;
    uint BiomeCount           = BiomeCountInfo;
    
    int VerticesAmount = (ChunkQuality + 1);
    float Size = (ChunkSize / ChunkQuality);
    
    uint x = DispatchThreadID.x;
    uint y = DispatchThreadID.y;
    if (x >= VerticesAmount || y >= VerticesAmount)
        return;
    
    float localX = x * Size;
    float localY = y * Size;
    float3 localPos = float3(localX, localY, 0.0);
    
    // Transform grid position to a point on the sphere.
    float3 PlanetPos = TransformLocation(ChunkLocation, ChunkRotation, localPos);
    float3 NormalizedPlanetPos = normalize(PlanetPos);
    PlanetPos = NormalizedPlanetPos * PlanetRadius;
    
    
    float erosion = 0.0;
    float finalElevation = 0.0;
    int biomeIndex = 0;
    uint3 top3BiomeIndices = uint3(0, 0, 0);
    float3 top3BiomeStrengths = float3(0, 0, 0);
    uint ForestNoise = 0;







    
//---------------------------------------------------------------------------------------
//Write your planet generation logic below. Use the PlanetPos variable as the position for noise sampling.
//Noise functions are available in the NoiseLib.usf file.
//PlanetType is the same variable you set in planet data asset.
//Use RecompileShaders changed command in editor to apply changes.
//---------------------------------------------------------------------------------------
    
#if PlanetType == 0

    PlanetPos *= 0.00000015;
    
    float3 shiftedPos = warpPosition(PlanetPos, 0.1);
    
    float tectonicEffect = computeInstantPlateEffect(shiftedPos, 0.6) * 0.4;
    
    tectonicEffect = clamp(tectonicEffect / 1.25 + 0.15, -1.0, 1.0);
    
    float HillNoise   = ErosionHeightTriplanar(PlanetPos * 40, 1, erosion) / 1.25;
    HillNoise += fbmE(PlanetPos * (200.0), 12, 1.0) * 0.02;


    
    //use this function to sample the biome blended curves that you set up in the curve atlas texture.
    float3 CurveHeight = sampleBlendedCurve(PlanetPos, HillNoise, tectonicEffect - 0.2, erosion, BiomeCount, biomeIndex, top3BiomeIndices, top3BiomeStrengths);
    HillNoise = CurveHeight.x;
    erosion = -CurveHeight.z;
    
    finalElevation = HillNoise * max(tectonicEffect * 1.5, 0.2);
    tectonicEffect = CurveHeight.y;
    finalElevation+= tectonicEffect;


    if (ReadBiomeDataTexture(biomeIndex, 3) >= 0.95) // Check if biome is forest biome
    {
        ForestNoise = uint((fbmE(PlanetPos * 50, 3, 1.0) - 0.6) * 255);
    }

    
#else
    
    finalElevation = ((fbmCraters(PlanetPos)) * 2 - 1) * 2.0;
    finalElevation = finalElevation * 0.5 + 1.5;
    
    finalElevation += (fbmE(PlanetPos * 100.0, 5, 1.0) * 2 - 1) * 0.007;
    biomeIndex = 0;
    
#endif


    
//---------------------------------------------------------------------------------------
//Planet generation logic ends here.
//---------------------------------------------------------------------------------------




    

    InputRenderTarget[DispatchThreadID.xy] = float4(float3(top3BiomeIndices.x / 255.0, top3BiomeIndices.y / 255.0, top3BiomeIndices.z / 255.0), (clamp(finalElevation, -1, 0) + 1));
    InputRenderTarget[DispatchThreadID.xy + int2(0, VerticesAmount)] = float4(top3BiomeStrengths, 1.0);

    uint index = (y * VerticesAmount + x) * 3;
    PlanetPos = NormalizedPlanetPos * (PlanetRadius + finalElevation * noiseHeight);
    PlanetPos = PlanetPos - (ChunkOriginLocation - ChunkLocation);
    float3 ChunkLocalPos = PlanetPos - ChunkLocation;
    Output[index]     = ChunkLocalPos.x;
    Output[index + 1] = ChunkLocalPos.y;
    Output[index + 2] = ChunkLocalPos.z;
    OutputVC[index] = uint(erosion * 255);
    OutputVC[index + 1] = ForestNoise;
    OutputVC[index + 2] = uint(biomeIndex);

}
